---
layout: post
title: 前端中高级面试精华荟萃（上）
categories: JavaScript
description: 前端中高级面试精华
keywords: JS, 前端, JavaScript, 面试
---

<!-- > 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。&nbsp; &nbsp;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 -->

<!-- > 如果你仍爱策马高游，倒不妨择一个日闲气清的节令，来与我对弈；我当卷袖煮茶，捻须鏖战，似当年战场。 -->

&emsp;&emsp;诗曰：雨过白鹭州，留恋铜雀楼；斜阳染幽草，几度飞红，摇曳了红鲤般似水年华。回想前端日久，曾梦想振翅翱翔，然，大厂之路，群雄林立，英才辈出；如若你初心不改，仍爱策马高游，倒不妨择一个日闲气清的节令，卷袖煮茶，潜心学问，与众名家捻须鏖战，似当年战场。

## 楔子

&emsp;&emsp;入坑前端两年有余，深知自己乃沧海之一粟，蜉蝣于天地；前端广阔，唯有不断学习与实践才能有立足之地。然后，互联网为我们的学习带来更多便捷的同时，却也让我们在琳琅满目的学习资料中迷失自我。

&emsp;&emsp;身为一个互联网人，我们不应该让资料的获取成为自己发展进步的阻碍，本着取之于社区、用之于社区的原则，欢迎对资料获取有困难（不限于视频、专栏等）、以及希望共同交流学习的朋友通过[我的博客](https://king-hcj.github.io/){:target='_blank'}页面扫码添加微信，免费获取资料，大家共同学习进步。

&emsp;&emsp;言归正传， 前端中高级面试精华 系列文章，预计分为上、中、下三个模块，主要对前端一些比较核心、底层的原理进行精练扼要的探讨，辅以相应模块经典文章推荐。也许我的级别并不足以完全掌控这些知识面，工作之余，精力也是有限，希望有朋友能参与到[本专栏](https://segmentfault.com/blog/king-hcj){:target='_blank'}的维护中来，大家共同为社区做出一点微末贡献。

<!-- - 精华文章点评、总结加推荐（推荐理由）；
- 文章不能只是推荐合集，应该是面试点的总结提炼和升华。 -->

## 回望来时路 —— 前端发展史

<!-- 前端发展史（JavaScript 20 年） -->

&emsp;&emsp;之所以选择这个题目作为本系列的开篇，是因为作为前端，我们多多少少需要知道一些前端的发展历程，是什么造就了今天这个繁荣的前端环境。正如我们在自己前端进阶的历程中，一路走来，有成功、有失败，有欢欣雀跃，更有黯然神伤。

&emsp;&emsp;[JavaScript 20 年](https://cn.history.js.org/){:target='_blank'}由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。全文不仅讲解了大量语言技术细节层面的演进，更复盘了更高层面上规范制定与标准博弈中的历史成败，是一部讲述人类如何在商业与技术上的竞争合作中促进产业发展的故事。

&emsp;&emsp;这个故事相当漫长而复杂。全文分为四个部分，每部分都对应 JavaScript 演化历程中的一个主要阶段。各部分之间还有一段简短的插曲，介绍彼时的开发者们是如何看待与使用 JavaScript 的。

- [JavaScript 20 年 - 完整版](https://cn.history.js.org/){:target='_blank'}
- [JavaScript 恩仇录 - 简明版](https://www.yuque.com/dingwentao/blog/ti968l){:target='_blank'}

## 相伴日久 —— 浏览器

&emsp;&emsp;作为一名前端开发人员，学习浏览器的内部工作原理将有助于我们在开发中作出更明智的决策，并理解那些最佳开发实践的个中缘由。在前端面试中，也有一道经典的面试题 ——【从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么】。

- [浏览器是如何工作的：Chrome V8让你更懂JavaScript](https://segmentfault.com/a/1190000037435824){:target='_blank'}
- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/){:target='_blank'}
- [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872){:target='_blank'}

## 前后端的桥梁 —— HTTP

- http2 http3

- [彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231){:target='_blank'}

## 构建打包 —— webpack

- [webpack打包原理 ? 看完这篇你就懂了 !](https://segmentfault.com/a/1190000021494964)
- [深入浅出 Webpack - 开源书籍](https://webpack.wuhaolin.cn/)
- [手把手教你撸一个简易的 webpack](https://zhuanlan.zhihu.com/p/37864523){:target='_blank'}

过时了，可以读一读
- [入门 Webpack，看这篇就够了](https://segmentfault.com/a/1190000006178770){:target='_blank'}

重点关注文末的文章
- [jsliang 求职系列 - 31 - Webpack](https://juejin.cn/post/6901807555316547597){:target='_blank'}

## webpack的loader的原理和实现

- [webpack的loader的原理和实现](https://www.cnblogs.com/lyraLee/p/12050811.html)

## tree shaking

tree-shaking 作为 rollup 的一个杀手级特性，能够利用ES6的静态引入规范，减少包的体积，避免不必要的代码引入。

Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。

Tree-shaking 是 DCE 的一种新的实现，Javascript同传统的编程语言不同的是，javascript绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对javascript来说更有意义。

Tree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注宇消除没有用到的代码。

ES6 module 特点：
  - 只能作为模块顶层的语句出现
  - import 的模块名只能是字符串常量
  - import binding 是 immutable的
  - ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。

所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。

Tree-Shaking原理：

  - ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。
  - 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。



- [rollup.js 中文文档](https://www.rollupjs.com/){:target='_blank'}
- [深入浅出模块化（含 tree shaking）（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99c75dccb24267c1d01bb6){:target='_blank'}
- [Tree-Shaking性能优化实践 - 原理篇](https://juejin.cn/post/6844903544756109319){:target='_blank'}
- [Tree-Shaking性能优化实践 - 实践篇](https://juejin.cn/post/6844903544760336398){:target='_blank'}
- [tree-shaking不完全指南](https://juejin.cn/post/6844903553295712269){:target='_blank'}
- [你的Tree-Shaking并没什么卵用](https://juejin.cn/post/6844903549290151949){:target='_blank'}
- [Webpack Tree shaking 深入探究](https://juejin.cn/post/6844903687412776974){:target='_blank'}
- [Webpack 中的 sideEffects 到底该怎么用？](https://zhuanlan.zhihu.com/p/40052192){:target='_blank'}

## esbuild、snowpack和vite

在如今（2019年），我们完全可以抛弃打包工具，而直接在浏览器中使用浏览器原生的 JavaScript 模块功能。这主要基于三点考虑：

  - 兼容性可接受：基本主流的浏览器版本都支持直接使用 JavaScript Module 了（当然，IE 一如既往除外）。
  - 性能问题的改善：之前打包的一个重要原因是 HTTP/1.1 的特性导致，我们合并请求来优化性能；而如今 HTTP/2 普及之后，这个性能问题不像以前那么突出了。
  - 打包的必要性：打包工具的存在主要就是为了处理模块化与合并请求，而以上两点基本解决这两个问题；再加之打包工具越来越复杂，此消彼长，其存在的必要性自然被作者所质疑。


&emsp;&emsp;Vite，**一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用**。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。

&emsp;&emsp;snowpack 的最初版核心目标就是不再打包业务代码，而是直接使用浏览器原生的 JavaScript Module 能力。

- [精读《snowpack和vite》](https://www.yuque.com/xixiaobai/xomql8/ironhk){:target='_blank'}
- [如何看待 Web 开发构建工具 Vite？](https://www.zhihu.com/question/394062839/answer/1496127786){:target='_blank'}
- [替代 webpack？带你了解 snowpack 原理，你还学得动么](https://zhuanlan.zhihu.com/p/149351900){:target='_blank'}
- [import - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import){:target='_blank'}
- [前端新工具--vite从入门到实战（一）](https://zhuanlan.zhihu.com/p/149033579){:target='_blank'}
- [彻底告别编译 OOM，用 esbuild 做压缩器](https://zhuanlan.zhihu.com/p/139219361){:target='_blank'}
- [esbuild, 一个用 GO 语言写的 Javascript 打包工具，比 Webpack 快接近 100 倍](https://segmentfault.com/a/1190000022709634){:target='_blank'}
- [下一个时代的打包工具 esbuild](https://blog.csdn.net/qq_42049445/article/details/109128382){:target='_blank'}
- [esbuild文档](https://esbuild.github.io/){:target='_blank'}

## 异步加载 懒加载

- [ES6+ import()：懒加载，异步加载组件](https://www.dazhuanlan.com/2019/11/14/5dccd8074fbb0/)
- require.ensure（）
- [按需加载](https://umijs.org/zh-CN/docs/load-on-demand)

## 高阶组件

- [深入理解 React 高阶组件](https://www.jianshu.com/p/0aae7d4d9bc1)

## `Object.defineProperty()`和`Object.Proxy()`，Vue 的取与舍

- [触类旁通多种框架](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbef7cbbbba80861a35c23)
  - 监听数组变化：Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是 push API 调用操作。
  - Object.defineProperty VS Proxy
    Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写
    Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历
    Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的
    Proxy 支持代理数组的变化
    Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举
    Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点
- [Vue响应式原理-理解Observer、Dep、Watcher](https://juejin.cn/post/6844903858850758670)
- [关于vue中如何监听数组变化](https://www.cnblogs.com/qianxiaox/p/13750909.html)
- [Object.defineProperty与Proxy理解整理](https://blog.csdn.net/qq_42833001/article/details/83302149)
- [数据劫持 OR 数据代理](https://mp.weixin.qq.com/s/SPoxin9LYJ4Bp0goliEaUw)

## JavaScript继承实现的得与失

## vue的Virtual Dom实现- snabbdom解密

- [vue的Virtual Dom实现- snabbdom解密](https://www.cnblogs.com/xuntu/p/6800547.html)
- [译文 - 基于虚拟DOM(Snabbdom)的迷你React](https://segmentfault.com/a/1190000019053542)

## React 和 Vue

- [你不知道的React 和 Vue 的20个区别【源码层面】](https://segmentfault.com/a/1190000023110217){:target='_blank'}
- [Vue.nextTick 的原理和用途](https://segmentfault.com/a/1190000012861862){:target='_blank'}
- [React Hooks完全上手指南](https://zhuanlan.zhihu.com/p/92211533){:target='_blank'}

## 抽象语法树(AST)

- [AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解](https://segmentfault.com/a/1190000016231512){:target='_blank'}
- [AST生成](https://astexplorer.net/){:target='_blank'}
- [Parser API](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API){:target='_blank'}

## 观察者模式 vs 发布订阅模式

&emsp;&emsp;设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

&emsp;&emsp;1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。

&emsp;&emsp;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的**解决方案**。通俗一点说，**设计模式是在某种场合下对某个问题的一种解决方案**。如果再通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。

&emsp;&emsp;这些“好的设计”并不是谁发明的，而是早已存在于软件开发中。一个稍有经验的程序员**也许在不知不觉中数次使用过这些设计模式**。GoF（Gang of Four–四人组，《设计模式》几位作者）最大的功绩是把这些“好的设计”从浩瀚的面向对象世界中挑选出来，并且给予它们一个好听又好记的名字。

&emsp;&emsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案，他不是一个死的机制，他是一种思想，一种写代码的形式。

```html

<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>发布订阅模式</title>
</head>
<body>
  <script>
    // 事件触发器
    class EventEmitter {
      constructor () {
        // { 'click': [fn1, fn2], 'change': [fn] }
        this.subs = Object.create(null)
      }

      // 注册事件
      $on (eventType, handler) {
        this.subs[eventType] = this.subs[eventType] || []
        this.subs[eventType].push(handler)
      }

      // 触发事件
      $emit (eventType) {
        if (this.subs[eventType]) {
          this.subs[eventType].forEach(handler => {
            handler()
          })
        }
      }
    }

    // 测试
    let em = new EventEmitter()
    em.$on('click', () => {
      console.log('click1')
    })
    em.$on('click', () => {
      console.log('click2')
    })

    em.$emit('click')
  </script>
</body>
</html>
```

```html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>观察者模式</title>
</head>
<body>
  <script>
    // 发布者-目标
    class Dep {
      constructor () {
        // 记录所有的订阅者
        this.subs = []
      }
      // 添加订阅者
      addSub (sub) {
        if (sub && sub.update) {
          this.subs.push(sub)
        }
      }
      // 发布通知
      notify () {
        this.subs.forEach(sub => {
          sub.update()
        })
      }
    }
    // 订阅者-观察者
    class Watcher {
      update () {
        console.log('update')
      }
    }

    // 测试
    let dep = new Dep()
    let watcher = new Watcher()

    dep.addSub(watcher)

    dep.notify()
  </script>
</body>
</html>
```

&emsp;&emsp;观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。【订阅报纸】

&emsp;&emsp;其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。【微博、专栏关注】

观察者模式和发布订阅模式有什么区别？

  - 观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

  - 发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。**观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。**

从表面上看：

  - 观察者模式里，只有两个角色 —— 观察者 + 被观察者
  - 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人Broker

往更深层次讲：

  - 观察者和被观察者，是松耦合的关系
  - 发布者和订阅者，则完全不存在耦合

从使用层面上讲：

  - 观察者模式，多用于单个应用内部
  - 发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件

- [译 - 观察者模式 vs 发布订阅模式](https://zhuanlan.zhihu.com/p/51357583){:target='_blank'}
- [发布订阅模式与观察者模式](https://blog.csdn.net/hf872914334/article/details/88899326){:target='_blank'}
- [JAVA设计模式总结之23种设计模式](https://www.cnblogs.com/pony1223/p/7608955.html){:target='_blank'}【多UML结构图，推荐】
- [Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/){:target='_blank'}【多UML结构图，推荐】

## webpack 插件原理

- [webpack 插件原理](https://blog.zfanw.com/how-webpack-plugin-works/)
- [揭秘webpack插件的工作原理](https://segmentfault.com/a/1190000023016347)
- [🔥Webpack 插件开发如此简单！](https://juejin.cn/post/6844904070868631560)
- [webpack插件机制之Tapable](https://juejin.cn/post/6844903774645911566)
- [Webpack 常见插件原理分析](https://www.jianshu.com/p/108d07de0e01)

## Webpack 热更新实现原理分析

- [Webpack 热更新实现原理分析](https://zhuanlan.zhihu.com/p/30623057)

## 前端路由

- [[实践系列] 前端路由](https://juejin.cn/post/6844903759458336776)
- [前端路由简介以及vue-router实现原理](https://zhuanlan.zhihu.com/p/37730038){:target='_blank'}

## Babel原理

- [[实践系列]Babel原理](https://juejin.cn/post/6844903760603398151)
- [一口（很长的）气了解 babel](https://zhuanlan.zhihu.com/p/43249121){:target='_blank'}

## 浏览器缓存机制

- [实践这一次,彻底搞懂浏览器缓存机制](https://juejin.cn/post/6844903764566999054)

## Nginx

- [前端开发者必备的nginx知识](https://segmentfault.com/a/1190000018454271)

## Linux

- [前端&后端程序员必备的Linux基础知识](https://www.cnblogs.com/kkdn/p/9295039.html)
- [前端linux基础，这一篇就够了](https://juejin.cn/post/6844903801283952653){:target='_blank'}
- [使用linux发布前端项目](https://xiaozhuanlan.com/topic/1956032748){:target='_blank'}
- [前端应该掌握的linux命令和工具](https://segmentfault.com/a/1190000010421178){:target='_blank'}

## ajax跨域，这应该是最全的解决方案了

- [ajax跨域，这应该是最全的解决方案了](https://segmentfault.com/a/1190000012469713){:target='_blank'}

## Build your own React

- [Build your own React](https://pomb.us/build-your-own-react/){:target='_blank'}

## React 性能的飞跃 —— Fiber

- [React Fiber Architecture](https://github.com/acdlite/react-fiber-architecture){:target='_blank'}
- [React Fiber架构](https://zhuanlan.zhihu.com/p/37095662){:target='_blank'}
- [React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127){:target='_blank'}
- [前端工程师的自我修养：React Fiber 是如何实现更新过程可控的](https://www.zoo.team/article/about-react-fiber){:target='_blank'}
- [React Fiber是什么](https://zhuanlan.zhihu.com/p/26027085){:target='_blank'}
- [A deep dive into React Fiber internals](https://blog.logrocket.com/deep-dive-into-react-fiber-internals/){:target='_blank'}
- [React的新引擎—React Fiber是什么？](https://www.infoq.cn/article/what-the-new-engine-of-react/)

## loader 插件 npm包 自动化构建工具

## 性能优化

## 前端微服务

## serverless

## 低代码开发平台

## GraphQL

## Immutable Data

Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 **Persistent Data Structure（持久化数据结构）**，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 **Structural Sharing（结构共享）**，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

Immutable.js 持久化数据结构的基本实现原理：
  - 核心数据结构Vector Trie。位分区机制：采用位分区的根本原因是为了优化速度；
  - 对于空间的优化： Immutable.js 参考了HAMT（hash array mapped trie）对树进行了高度和节点内部的压缩，此外，还对操作效率进行了其它一些优化。

- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3){:target='_blank'}【图】
- [深入探究immutable.js的实现机制（一）](https://zhuanlan.zhihu.com/p/44571842){:target='_blank'}
- [深入探究immutable.js的实现机制（二）](https://zhuanlan.zhihu.com/p/45106741){:target='_blank'}
- [Functional Go: 持久化数据结构简介](https://io-meter.com/2016/09/03/Functional-Go-persist-datastructure-intro/){:target='_blank'}

## SEO优化

[第一、二、三、四代搜索引擎分别指什么，对应网站分别有哪些？](https://zhidao.baidu.com/question/229530305.html)
[第四代搜索引擎前沿综述](https://wenku.baidu.com/view/16418bec4afe04a1b071de0b.html)

> [SEO算法](https://www.ainiseo.com/category/suanfa)

> [谷歌SEO](https://www.ainiseo.com/category/google-seo)

> [SEO算法](http://www.sclangge.com/suanfa/)

- https://www.kuanxu.com/seo/39.html
- https://wiki.jikexueyuan.com/project/seo/37.html
- https://juejin.cn/post/6844903824428105735
- https://github.com/cisen/blog/issues/570
- https://lusongsong.com/reed/7657.html


- Prerender预渲染优化SEO：https://github.com/prerender/prerender
- https://love.fishman.wang/2016/05/06/prerender%E9%A2%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96SEO/

- https://blog.naibabiji.com/google-seo

- https://static.googleusercontent.com/media/www.google.com/zh-CN//intl/zh-CN/webmasters/docs/search-engine-optimization-starter-guide-zh-cn.pdf

- https://prerender.io/

- https://blog.csdn.net/zai_xia/article/details/86697300
- https://deliverr.com/zh/blog/shopify-seo/

## BFC

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

- [BFC 背后的布局问题](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbeaf5bbbba80861a35c03)
- [10 分钟理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)

##  饱受诟病的原型继承有什么优势？

- [类继承和原型继承的区别](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbe961bbbba80861a35bfd)
- [征服 JavaScript 面试：类继承和原型继承的区别](https://mp.weixin.qq.com/s/CqXmu4n6aZsqB-jJ0O0t-g)

## 前端灾备 —— 容灾和恢复

- [容错，高可用和灾备](http://www.ruanyifeng.com/blog/2019/11/fault-tolerance.html)
- [前端容灾](https://juejin.cn/post/6844903623722287117)
- [【灾备知识总结】容灾与备份区别、灾备技术、容灾体系规划](http://www.cfdzsw.com/2019/09/07/%e3%80%90%e7%81%be%e5%a4%87%e7%9f%a5%e8%af%86%e6%80%bb%e7%bb%93%e3%80%91%e5%ae%b9%e7%81%be%e4%b8%8e%e5%a4%87%e4%bb%bd%e5%8c%ba%e5%88%ab%e3%80%81%e7%81%be%e5%a4%87%e6%8a%80%e6%9c%af%e3%80%81%e5%ae%b9/)
- [浅谈容灾测试](https://www.cnblogs.com/imyalost/p/8290567.html)
- [前端网站容灾-CDN主域重试方案](https://www.sohu.com/a/396397337_495695)
- [从“挖光缆”到“剪网线”|蚂蚁金服异地多活单元化架构下的微服务体系](https://juejin.cn/post/6844903705783828488)

## 灰度发布 和 A/B testing

- [一种前端灰度发布方案](https://www.cnblogs.com/lvdabao/p/11920919.html)
- [手把手教你搭建一个灰度发布环境](https://segmentfault.com/a/1190000022612488)
- [基于Nodejs的前端灰度发布方案](https://segmentfault.com/a/1190000018337322)
- [蓝绿部署、A/B测试以及灰度发布](https://segmentfault.com/a/1190000008542092) &#124; [译](https://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/)
- [微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布](https://www.jianshu.com/p/022685baba7d)
- [要进大厂？前端灰度发布必须要知道](https://juejin.cn/post/6844903969110622222)
- [Regal灰度发布智能分组引擎](https://segmentfault.com/a/1190000009867597)
- [基于 Nginx+lua+Memcache 实现灰度发布](https://segmentfault.com/a/1190000022834145)
- [前端灰度-前端项目如何进行灰度？](https://juejin.cn/post/6897090555868610574)
- [灰度部署、滚动部署与蓝绿部署](https://juejin.cn/post/6844903821173325838)
- [灰度发布-上线前的最后一公里](https://juejin.cn/post/6844903614910038030)

## 性能优化

## 服务端渲染(SSR)

&emsp;&emsp;SSR对于大部分场景最主要是考虑到两点：提高首屏加载速度 和 方便SEO。

### 概念解析

&emsp;&emsp;服务端渲染（Server-Side Rendering），是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。
&emsp;&emsp;简单理解是将组件或页面通过服务器**生成html字符串，再发送到浏览器**，最后将静态标记"混合"为客户端上完全可交互的应用程序。

- 没使用服务渲染时，当请求index.html页面时，返回的body里为空，之后执行js将html结构注入到body里，再结合css显示出来；
- 使用了服务端渲染，当请求index.html页面时，返回的body里已经有了首屏的html结构，之后结合css显示出来。

### SSR的利弊

- 优势
  - 更利于SEO。不同爬虫工作原理类似，大部分爬虫只会爬取源码，不会执行网站的任何脚本。
  - 更利于首屏渲染。首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。
  - 在服务端完成数据请求比在浏览器端效率要高。
  - 禁用了JavaScript的浏览器依然可以展示出服务端渲染的静态页面。
- 不足
  - 高并发访问的情况，会大量占用服务端CPU资源，服务端压力较大；
  - 开发条件受限，比如在服务端渲染中，只会执行到render及之前的生命周期钩子（组件没有被完整地“渲染”出来）；
  - 学习成本相对较高.除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。当然，现在也可以直接使用[Next.js](https://www.nextjs.cn/)和[Nuxt.js](https://www.nuxtjs.cn/)等SSR解决方案。

### React 服务端渲染 相关API 及 主要原理

- `renderToString`：对于服务端，通过调用`ReactDOMServer.renderToString`方法把Virtual DOM转换成HTML字符串返回给客户。`renderToString` 的功能是一口气同步产生最终 HTML，如果 React 组件树很庞大，这样一个同步过程可能比较耗时。
- `renderToNodeStream`：`renderToNodeStream` 把渲染结果以“流”的形式塞给 response 对象（这里的 response 是 express 或者 koa 的概念），这意味着不用等到所有 HTML 都渲染出来了才给浏览器端返回结果；
- [`hydrate`](http://www.ayqy.net/blog/ssr-hydrate/)：React v16 之后用 `React.hydrate` 替换 `React.render`，这个 [`hydrate` 就是“注水”](https://www.zhihu.com/question/66068748){:target='_blank'}，[render !== hydrate](https://zhuanlan.zhihu.com/p/33887159){:target='_blank'}。`hydrate()`配合 SSR 使用，与`render()`的区别在于渲染过程中能够复用服务端返回的现有 HTML 节点，只为其附加交互行为（事件监听等），并不重新创建 DOM 节点。

### 同构应用

&emsp;&emsp;一套代码既可以在服务端运行又可以在客户端运行，**在服务器端执行一次，用于实现服务器端渲染**，**在客户端再执行一次，用于接管页面交互**，这就是同构应用。简而言之, 就是服务端直出和客户端渲染的组合, 能够充分结合两者的优势，并有效避免两者的不足。

### 资料精华荟萃

- 原理：[浅谈服务端渲染(SSR)](https://www.jianshu.com/p/10b6074d772c) &#124; [React SSR之API篇](http://www.ayqy.net/blog/react-ssr-api/) &#124; [React SSR之原理篇](http://www.ayqy.net/blog/react-ssr-under-the-hood/)  &#124; [React SSR中的hydrate是什么意思？](http://www.ayqy.net/blog/ssr-hydrate/)
- 实践：[彻底理解React 之React SSR、React服务端渲染，教你从零搭建配置](https://www.jianshu.com/p/47c8e364d0bc)
- 进阶：[一文吃透 React SSR 服务端渲染和同构原理](https://segmentfault.com/a/1190000020417285)
- 视频资料推荐：[React服务器渲染原理解析与实践](https://coding.imooc.com/class/chapter/276.html)

## 安全和风险控制 —— 防攻击

## 前端自动化测试

- [京喜前端自动化测试之路](https://juejin.cn/post/6844904150631710727)

## Web Components

- html很宽松，浏览器也可以识别不规则、不合法标签（元素）（如`<custom-label>Web Components</custom-label>` 会展示"Web Components"。）；
- 自定义继承自`HTMLElement`的类，称为自定义元素的类；
- 经过`window.customElements.define`API定义和注册自定义元素，使得**不合法标签**（自定义元素）与自定义元素的类关联，实现**合法化**；
- 通过模板标签`<template>`简化类的定义过程并添加样式；
- 通过自定义元素的`attachShadow()`方法开启 Shadow DOM（这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部），隐藏自定义元素的内部实现；
- 添加事件监听、进行组件化封装等。

> 参考资料：[Web Components 入门实例教程-阮一峰](http://www.ruanyifeng.com/blog/2019/08/web_components.html){:target='_blank'} &#124; [Window.customElements](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/customElements){:target='_blank'} &#124; [Web Components](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components){:target='_blank'}

## 正则表达式

## 算法

- [前端该如何准备数据结构和算法？](https://segmentfault.com/a/1190000020122791)
- [面试助力，算法  101：JavaScript 描述](https://101.zoo.team/)
- [awesome-coding-js](http://www.conardli.top/docs/)

## yck

## 前端面试总结2020年8月16家公司(附真实面试题)

- [前端面试总结2020年8月16家公司(附真实面试题)](https://segmentfault.com/a/1190000023731057){:target='_blank'}
- [中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)](https://juejin.cn/post/6844903776512393224){:target='_blank'}
- [awesome-coding-js](http://www.conardli.top/docs/)


- [10 Interview Questions Every JavaScript Developer Should Know](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95#.y0nc8kx34)

