---
layout: post
title: 前端中高级面试精华荟萃（上）
categories: JavaScript
description: 前端中高级面试精华
keywords: JS, 前端, JavaScript, 面试
---

<!-- > 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。&nbsp; &nbsp;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 -->

<!-- > 如果你仍爱策马高游，倒不妨择一个日闲气清的节令，来与我对弈；我当卷袖煮茶，捻须鏖战，似当年战场。 -->

&emsp;&emsp;诗曰：雨过白鹭州，留恋铜雀楼；斜阳染幽草，几度飞红，摇曳了红鲤般似水年华。回想前端日久，曾梦想振翅翱翔，然，大厂之路，群雄林立，英才辈出；如若你初心不改，仍爱策马高游，倒不妨择一个日闲气清的节令，卷袖煮茶，潜心学问，与众名家捻须鏖战，似当年战场。

## 楔子

&emsp;&emsp;入坑前端两年有余，深知自己乃沧海之一粟，蜉蝣于天地；前端广阔，唯有不断学习与实践才能有立足之地。然后，互联网为我们的学习带来更多便捷的同时，却也让我们在琳琅满目的学习资料中迷失自我。

&emsp;&emsp;身为一个互联网人，我们不应该让资料的获取成为自己发展进步的阻碍，本着取之于社区、用之于社区的原则，欢迎对资料获取有困难（不限于视频、专栏等）、以及希望共同交流学习的朋友通过[我的博客](https://king-hcj.github.io/){:target='\_blank'}页面扫码添加微信，免费获取资料，大家共同学习进步。

&emsp;&emsp;言归正传， 前端中高级面试精华 系列文章，预计分为上、中、下三个模块，主要对前端一些比较核心、底层的原理进行精练扼要的探讨，辅以相应模块经典文章推荐。也许我的级别并不足以完全掌控这些知识面，工作之余，精力也是有限，希望有朋友能参与到[本专栏](https://segmentfault.com/blog/king-hcj){:target='\_blank'}的维护中来，大家共同为社区做出一点微末贡献。

<!-- - 精华文章点评、总结加推荐（推荐理由）；
- 文章不能只是推荐合集，应该是面试点的总结提炼和升华。 -->

## 回望来时路 —— 前端发展史

<!-- 前端发展史（JavaScript 20 年） -->

&emsp;&emsp;之所以选择这个题目作为本系列的开篇，是因为作为前端，我们多多少少需要知道一些前端的发展历程，是什么造就了今天这个繁荣的前端环境。正如我们在自己前端进阶的历程中，一路走来，有成功、有失败，有欢欣雀跃，更有黯然神伤。

&emsp;&emsp;[JavaScript 20 年](https://cn.history.js.org/){:target='\_blank'}由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。全文不仅讲解了大量语言技术细节层面的演进，更复盘了更高层面上规范制定与标准博弈中的历史成败，是一部讲述人类如何在商业与技术上的竞争合作中促进产业发展的故事。

&emsp;&emsp;这个故事相当漫长而复杂。全文分为四个部分，每部分都对应 JavaScript 演化历程中的一个主要阶段。各部分之间还有一段简短的插曲，介绍彼时的开发者们是如何看待与使用 JavaScript 的。

- [JavaScript 20 年 - 完整版](https://cn.history.js.org/){:target='\_blank'}
- [JavaScript 恩仇录 - 简明版](https://www.yuque.com/dingwentao/blog/ti968l){:target='\_blank'}

## 相伴日久 —— 浏览器

&emsp;&emsp;作为一名前端开发人员，学习浏览器的内部工作原理将有助于我们在开发中作出更明智的决策，并理解那些最佳开发实践的个中缘由。在前端面试中，也有一道经典的面试题 ——【从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么】。

- [The Story of the Web: A History Of Internet Browsers](https://www.internetadvisor.com/the-story-of-the-web-a-history-of-internet-browsers){:target='\_blank'}
- [THE HISTORY OF THE WEB BROWSER](https://minimalistwpthemes.com/history-of-the-web-browser/){:target='\_blank'}

- [浏览器是如何工作的：Chrome V8 让你更懂 JavaScript](https://segmentfault.com/a/1190000037435824){:target='\_blank'}
- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/){:target='\_blank'}
- [从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872){:target='\_blank'}
- [🤔 移动端 JS 引擎哪家强？美国硅谷找......](https://mp.weixin.qq.com/s/cV3RH72YKd6jRYBFhjJ-5w){:target='\_blank'}
- [Chrome 浏览器架构](https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3){:target='\_blank'}
- [图解浏览器的基本工作原理](https://zhuanlan.zhihu.com/p/47407398){:target='\_blank'}
- [Page Lifecycle API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events){:target='\_blank'}

- [自主研发一款浏览器内核的难度到底有多大？](https://www.zhihu.com/question/290564335/answer/474202037){:target='\_blank'}

- [浏览器市场占有率分析](https://zhuanlan.zhihu.com/p/187066428){:target='\_blank'}

- [浏览器市场份额](https://tongji.baidu.com/research/site){:target='\_blank'}
- [全球浏览器市场份额](https://gs.statcounter.com/){:target='\_blank'} &#124; [w3counter](https://www.w3counter.com/globalstats.php){:target='\_blank'}

JavaScriptCore：

- [深入剖析 JavaScriptCore](https://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/){:target='\_blank'}
- [深入理解 JSCore](https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html){:target='\_blank'}【关注一下参考资料】
- [JavaScriptCore 全面解析](https://juejin.cn/post/6844903765582053384){:target='\_blank'}
- [深入浅出 JavaScriptCore](https://www.jianshu.com/p/ac534f508fb0){:target='\_blank'}

- [各大浏览器内核(渲染引擎/JS 引擎)](https://www.dazhuanlan.com/2019/12/08/5decfc2eadb24/){:target='\_blank'}

## 前后端的桥梁 —— HTTP

- http2 http3

- [彻底搞懂 HTTPS 的加密机制](https://zhuanlan.zhihu.com/p/43789231){:target='\_blank'}
- [HTTPS 从认识到线上实战全记录](http://blog.haoji.me/https.html){:target='\_blank'}

## 构建打包 —— webpack

- **[把 webpack 热更新原理聊清楚](https://mp.weixin.qq.com/s/-DZ5vMaiOhFsOb9RDx71wg){:target='\_blank'}**
- **[面对 ESM 的开发模式，webpack 还有还手之力吗？](https://mp.weixin.qq.com/s/fvADDJQ598VMvqCrsxccOA){:target='\_blank'}**

- [[万字总结] 一文吃透 Webpack 核心原理](https://juejin.cn/post/6949040393165996040){:target='\_blank'}
- [细说 webpack 之流程篇](https://developer.aliyun.com/article/61047){:target='\_blank'}
- [webpack 打包原理 ? 看完这篇你就懂了 !](https://segmentfault.com/a/1190000021494964)
- [深入浅出 Webpack - 开源书籍](https://webpack.wuhaolin.cn/)
- [手把手教你撸一个简易的 webpack](https://zhuanlan.zhihu.com/p/37864523){:target='\_blank'}
- [webpack4.0 各个击破（8）—— tapable 篇](https://www.cnblogs.com/dashnowords/p/9572750.html){:target='\_blank'}
- [Webpack 源码（一）—— Tapable 和 事件流](https://segmentfault.com/a/1190000008060440){:target='\_blank'}
- [webpack4+学习笔记：8. CSS 样式抽离之 mini-css-extract-plugin 插件](https://blog.csdn.net/weixin_44101052/article/details/86578351){:target='\_blank'}
- [webpack-dev-server 原理分析与 HMR 实现](https://blog.csdn.net/liangklfang/article/details/56848925){:target='\_blank'}

过时了，可以读一读

- [入门 Webpack，看这篇就够了](https://segmentfault.com/a/1190000006178770){:target='\_blank'}

重点关注文末的文章

- [jsliang 求职系列 - 31 - Webpack](https://juejin.cn/post/6901807555316547597){:target='\_blank'}

## JS 内存泄漏排查方法

- [JS 内存泄漏排查方法——Chrome Profiles](https://f-e-d.club/topic/js-memory-leak-screening-method-chrome-profiles.article){:target='\_blank'}

## webpack loader 和 plugin 的原理与实现

compiler 和 compilation
compiler 和 compilation 这两个对象是 webpack 核心原理中最重要的概念。它们是理解 webpack 工作原理、loader 和插件工作的基础。

- compiler 对象：它的实例包含了完整的 webpack 配置，全局只有一个 compiler 实例，因此它就像 webpack 的骨架或神经中枢。当插件被实例化的时候，会收到一个 compiler 对象，通过这个对象可以访问 webpack 的内部环境。
- compilation 对象：当 webpack 以开发模式运行时，每当检测到文件变化，一个新的 compilation 对象将被创建。这个对象包含了当前的模块资源、编译生成资源、变化的文件等信息。也就是说，所有构建过程中产生的构建数据都存储在该对象上，它也掌控着构建过程中的每一个环节。该对象也提供了很多事件回调供插件做扩展。

loader 就是一个基于 CommonJS 规范的函数模块，它接受内容（这个内容可能是源文件也可能是经过其他 loader 处理后的结果），并返回新的内容。

```js
module.exports = function (source) {
  // some magic...
  return content;
};
```

一个自定义 webpack plugin 的骨架结构就是一个带有 apply 方法的 class。除了 compiler 暴露了与 webpack 整体构建生命周期相关的钩子以外，compilation 也暴露了与模块和依赖有关的粒度更小的钩子。

```js
class CustomPlugin {
  constructor(options) {
    this.options = options;
  }
  apply(compiler) {
    // 相关钩子注册回调
    compiler.hooks.someHook.tap('CustomPlugin', () => {
      // magic here...
    });

    // 打印出此时 compiler 暴露的钩子
    for (var hook of Object.keys(compiler.hooks)) {
      console.log(hook);
    }
  }
}

module.exports = customPlugin;
```

webpack 插件的套路：

- 定义一个 JavaScript class 函数，或在函数原型（prototype）中定义一个以 compiler 对象为参数的 apply 方法。
- apply 函数中通过 compiler 插入指定的事件钩子，在钩子回调中拿到 compilation 对象。
- 使用 compilation 操纵修改 webapack 打包内容。

- [webpack 的 loader 的原理和实现](https://www.cnblogs.com/lyraLee/p/12050811.html)
- [webpack 工程师和前端工程师（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c999b70a6dde326dc85814d){:target='\_blank'}
- [webpack-插件机制杂记](https://juejin.cn/post/6844903789804126222){:target='\_blank'}

## tree shaking

tree-shaking 作为 rollup 的一个杀手级特性，能够利用 ES6 的静态引入规范，减少包的体积，避免不必要的代码引入。

Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。

Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。

Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注宇消除没有用到的代码。

ES6 module 特点：

- 只能作为模块顶层的语句出现
- import 的模块名只能是字符串常量
- import binding 是 immutable 的
- ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。

所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。

Tree-Shaking 原理：

- ES6 的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。

- [rollup.js 中文文档](https://www.rollupjs.com/){:target='\_blank'}
- [深入浅出模块化（含 tree shaking）（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99c75dccb24267c1d01bb6){:target='\_blank'}
- [Tree-Shaking 性能优化实践 - 原理篇](https://juejin.cn/post/6844903544756109319){:target='\_blank'}
- [Tree-Shaking 性能优化实践 - 实践篇](https://juejin.cn/post/6844903544760336398){:target='\_blank'}
- [tree-shaking 不完全指南](https://juejin.cn/post/6844903553295712269){:target='\_blank'}
- [你的 Tree-Shaking 并没什么卵用](https://juejin.cn/post/6844903549290151949){:target='\_blank'}
- [Webpack Tree shaking 深入探究](https://juejin.cn/post/6844903687412776974){:target='\_blank'}
- [Webpack 中的 sideEffects 到底该怎么用？](https://zhuanlan.zhihu.com/p/40052192){:target='\_blank'}

## OT 算法

- [揭开在线协作的神秘面纱 - OT 算法](https://zhuanlan.zhihu.com/p/74562370){:target='\_blank'}
- [Operational Transformation 算法图解](https://blog.csdn.net/pheecian10/article/details/78496854){:target='\_blank'}
- [关于 OT 算法](https://www.yuque.com/zhangchi-qjghq/gfa80b/pitn93){:target='\_blank'}
- [OT 算法可视化](http://operational-transformation.github.io/index.html){:target='\_blank'}
- [协同编辑--OT 算法之外的世界](https://blog.csdn.net/pheecian10/article/details/81461390){:target='\_blank'}

## node 高并发与高可用

- [基于 Docker、NodeJs 实现高可用的服务发现](https://github.com/jasonGeng88/blog/blob/master/201704/service_discovery.md){:target='\_blank'}
- [nodejs 高并发大流量的控制并发的三种方法](http://mrdede.com/?p=3889){:target='\_blank'}
- [如何构建一个高可用的 node 环境](https://blog.csdn.net/qq_24073885/article/details/109580808){:target='\_blank'}：故障恢复、多核利用、多进程共享端口
- [分布式与集群的区别是什么？](https://www.zhihu.com/question/20004877){:target='\_blank'}

高可用

- NodeJs 自身通过 cluster 模块，进行多进程启动，防止单进程崩溃的不稳定性；
- 通过 Docker 容器化启动，在启动时设置 restart 策略，一旦服务崩溃将立即重启；
- 上述的使用场景都在单机上运行，在分布式情况下，可以将 NodeJs 容器多主机部署，采用 nginx + NodeJs 的架构进行水平扩展；

- [深入理解 js 事件循环机制（Node.js 篇）](http://lynnelv.github.io/js-event-loop-nodejs){:target='\_blank'}

## esbuild、snowpack 和 vite

在如今（2019 年），我们完全可以抛弃打包工具，而直接在浏览器中使用浏览器原生的 JavaScript 模块功能。这主要基于三点考虑：

- 兼容性可接受：基本主流的浏览器版本都支持直接使用 JavaScript Module 了（当然，IE 一如既往除外）。
- 性能问题的改善：之前打包的一个重要原因是 HTTP/1.1 的特性导致，我们合并请求来优化性能；而如今 HTTP/2 普及之后，这个性能问题不像以前那么突出了。
- 打包的必要性：打包工具的存在主要就是为了处理模块化与合并请求，而以上两点基本解决这两个问题；再加之打包工具越来越复杂，此消彼长，其存在的必要性自然被作者所质疑。

## npm/yarn install 原理

主要分为两个部分, 首先，执行 npm/yarn install 之后，包如何到达项目 node_modules 当中。其次，node_modules 内部如何管理依赖。

执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:

- 1. 将依赖包的版本区间解析为某个具体的版本号
- 2. 下载对应版本依赖的 tar 包到本地离线镜像
- 3. 将依赖从离线镜像解压到本地缓存
- 4. 将依赖从缓存拷贝到当前目录的 node_modules 目录

- [为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://mp.weixin.qq.com/s/2LJmkcNfH9MHp597xjdIyQ){:target='\_blank'}

&emsp;&emsp;Vite，**一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用**。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。

&emsp;&emsp;snowpack 的最初版核心目标就是不再打包业务代码，而是直接使用浏览器原生的 JavaScript Module 能力。

- [精读《snowpack 和 vite》](https://www.yuque.com/xixiaobai/xomql8/ironhk){:target='\_blank'}
- [如何看待 Web 开发构建工具 Vite？](https://www.zhihu.com/question/394062839/answer/1496127786){:target='\_blank'}
- [替代 webpack？带你了解 snowpack 原理，你还学得动么](https://zhuanlan.zhihu.com/p/149351900){:target='\_blank'}
- [import - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import){:target='\_blank'}
- [前端新工具--vite 从入门到实战（一）](https://zhuanlan.zhihu.com/p/149033579){:target='\_blank'}
- [彻底告别编译 OOM，用 esbuild 做压缩器](https://zhuanlan.zhihu.com/p/139219361){:target='\_blank'}
- [esbuild, 一个用 GO 语言写的 Javascript 打包工具，比 Webpack 快接近 100 倍](https://segmentfault.com/a/1190000022709634){:target='\_blank'}
- [下一个时代的打包工具 esbuild](https://blog.csdn.net/qq_42049445/article/details/109128382){:target='\_blank'}
- [esbuild 文档](https://esbuild.github.io/){:target='\_blank'}

## 实现一个模板引擎

```js
// 模版引擎

// 实现一
// function tmpl(str, data) {

//     var string = "var p = []; p.push('" +
//     str
//     .replace(/[\r\t\n]/g, "")
//     .replace(/<%=(.*?)%>/g, "');p.push($1);p.push('")
//     .replace(/<%/g, "');")
//     .replace(/%>/g,"p.push('")
//     + "');"

//     eval(string)

//     document.body.innerHTML = p.join('');
//     // return p.join('');
// };

// 实现二
function tmpl(str, data) {
  var fn = new Function(
    'obj',

    "var p = []; p.push('" +
      str
        .replace(/[\r\t\n]/g, '')
        .replace(/<%=(.*?)%>/g, "');p.push($1);p.push('")
        .replace(/<%/g, "');")
        .replace(/%>/g, "p.push('") +
      "');return p.join('');"
  );

  // 转换后的函数fn
  // (function anonymous(obj) {
  //     var p = [];
  //     p.push('');
  //     for (var i = 0; i < users.length; i++) {
  //         p.push('    <li>        <a href="');
  //         p.push(users[i].url);
  //         p.push('">            ');
  //         p.push(users[i].name);
  //         p.push('        </a>    </li>');
  //     }
  //     p.push('');
  //     return p.join('');
  //   }
  // )

  // return fn(data);
  document.body.innerHTML = fn(data);
}

// 实现三
// 现在有一个小问题，就是实际上我们传入的数据结构可能比较复杂
// function tmpl(str, data) {
//     var fn = new Function("obj",//其实就是这里多添加了一句 with(obj){...}
//     "var p = []; with(obj){p.push('" +

//     str
//     .replace(/[\r\t\n]/g, "")
//     .replace(/<%=(.*?)%>/g, "');p.push($1);p.push('")
//     .replace(/<%/g, "');")
//     .replace(/%>/g,"p.push('")
//     + "');}return p.join('');");
//     console.log(fn);

//     document.body.innerHTML = fn(data);
// };

var users = [
  { name: 'Byron', url: 'http://localhost' },
  { name: 'Casper', url: 'http://localhost' },
  { name: 'Frank', url: 'http://localhost' },
];

// 模版
// <%for ( var i = 0; i < users.length; i++ ) { %>
//     <li>
//         <a href="<%=users[i].url%>">
//             <%=users[i].name%>
//         </a>
//     </li>
// <% } %>

tmpl(
  `<%for ( var i = 0; i < users.length; i++ ) { %>
    <li>
        <a href="<%=users[i].url%>">
            <%=users[i].name%>
        </a>
    </li>
<% } %>`,
  users
);
```

```js
// 结合playground.html
function tmpl(data) {
  let str = document.getElementById('user_tmpl').innerHTML;

  var fn = new Function(
    'obj',

    "var p = []; p.push('" +
      str
        .replace(/[\r\t\n]/g, '')
        .replace(/<%=(.*?)%>/g, "');p.push($1);p.push('")
        .replace(/<%/g, "');")
        .replace(/%>/g, "p.push('") +
      "');return p.join('');"
  );

  // return fn(data);
  document.getElementById('container').innerHTML = fn(data);
}

var users = [
  { name: 'Byron', url: 'http://localhost' },
  { name: 'Casper', url: 'http://localhost' },
  { name: 'Frank', url: 'http://localhost' },
];
tmpl(users);
```

- 一些报错：
  `Uncaught EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: "script-src github.githubassets.com".`

- [underscore 系列之实现一个模板引擎(上)](https://github.com/mqyqingfeng/Blog/issues/63){:target='\_blank'}
- [JavaScript Micro-Templating](https://johnresig.com/blog/javascript-micro-templating/){:target='\_blank'}

## Event Loop（事件循环）

- [进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html){:target='\_blank'}
- [什么是 Event Loop？](http://www.ruanyifeng.com/blog/2013/10/event_loop.html){:target='\_blank'}
- [JavaScript 运行机制详解：再谈 Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html){:target='\_blank'}
- [由 setTimeout 和 setImmediate 执行顺序的随机性窥探 Node 的事件循环机制](https://segmentfault.com/a/1190000013102056){:target='\_blank'}
- [如何理解单线程的 JavaScript 及其工作原理](https://juejin.cn/post/6991241111167565860){:target='\_blank'}

## 异步加载 懒加载

- [ES6+ import()：懒加载，异步加载组件](https://www.dazhuanlan.com/2019/11/14/5dccd8074fbb0/)
- require.ensure（）
- [按需加载](https://umijs.org/zh-CN/docs/load-on-demand)

## Promise.all 并发限制

批次还是保持 10 个？【批次看第一篇文章评论】

- [Promise.all 并发限制](https://segmentfault.com/a/1190000016389127){:target='\_blank'}
- [Promise 面试题 3 控制并发](https://blog.csdn.net/tonghonglei/article/details/88054116){:target='\_blank'}
- [使用 Promise 并发限制](https://www.cnblogs.com/fuGuy/p/13112876.html){:target='\_blank'}

## 高阶组件

- [深入理解 React 高阶组件](https://www.jianshu.com/p/0aae7d4d9bc1)

## `Object.defineProperty()`和`Object.Proxy()`，Vue 的取与舍

- [触类旁通多种框架](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbef7cbbbba80861a35c23)
  - 监听数组变化：Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是 push API 调用操作。
  - Object.defineProperty VS Proxy
    Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写
    Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历
    Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的
    Proxy 支持代理数组的变化
    Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举
    Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点
- [Vue 响应式原理-理解 Observer、Dep、Watcher](https://juejin.cn/post/6844903858850758670)
- [关于 vue 中如何监听数组变化](https://www.cnblogs.com/qianxiaox/p/13750909.html)
- [Object.defineProperty 与 Proxy 理解整理](https://blog.csdn.net/qq_42833001/article/details/83302149)
- [数据劫持 OR 数据代理](https://mp.weixin.qq.com/s/SPoxin9LYJ4Bp0goliEaUw)

## JavaScript 继承实现的得与失

## BFF 层

- [Backend For Frontend (BFF)](http://www.ayqy.net/blog/backend-for-frontend-bff/)
- [BFF —— Backend For Frontend](https://www.jianshu.com/p/eb1875c62ad3)
- [初识 BFF 架构设计](https://blog.csdn.net/weixin_42033269/article/details/102456306)
- [微服务架构中的 BFF 到底是啥？](https://blog.csdn.net/Itmylove8/article/details/107295816/)
- [BFF 困境与思考](https://blog.csdn.net/YcoeXu/article/details/103055582)
- [基于函数计算的 BFF 架构](https://zhuanlan.zhihu.com/p/123249620)

## vue 的 Virtual Dom 实现- snabbdom 解密

- [vue 的 Virtual Dom 实现- snabbdom 解密](https://www.cnblogs.com/xuntu/p/6800547.html)
- [译文 - 基于虚拟 DOM(Snabbdom)的迷你 React](https://segmentfault.com/a/1190000019053542)

## React 和 Vue

- [你不知道的 React 和 Vue 的 20 个区别【源码层面】](https://segmentfault.com/a/1190000023110217){:target='\_blank'}
- [Vue.nextTick 的原理和用途](https://segmentfault.com/a/1190000012861862){:target='\_blank'}
- [React Hooks 完全上手指南](https://zhuanlan.zhihu.com/p/92211533){:target='\_blank'}
- [没有用到 React，为什么我需要 import 引入 React?](https://www.cnblogs.com/zhaohongcheng/p/11234166.html){:target='\_blank'}
- **[精读《DOM diff 原理详解》](https://mp.weixin.qq.com/s/KCX8xwY563qCAJqaK2H2EA){:target='\_blank'}**

## Redux 原理及中间件

```js
// 中间件模版
export default store => next => action => {
  if (action.type === 'aaa') {
    // 延迟两秒执行
    setTimeout(() => {
      next(action)
    }, 2000);
  }
}
// 在中间件最后，不要忘了执行next(action)
// 复杂中间件：可以通过判断action的类型，如果是个函数，把dispatch传给函数执行，不是函数(即对象)则正常执行
// 下面的就是redux-thunk原理
export default store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch)
  }
  next(action)
}
```

- **[Redux/react-redux/redux 中间件设计实现剖析](https://mp.weixin.qq.com/s/hlwe0Z9Bhwyz2srHGJGigA){:target='\_blank'}**
- [redux 中间件的原理——从懵逼到恍然大悟](https://zhuanlan.zhihu.com/p/34651008){:target='\_blank'}
- [Redux 的中间件原理分析](https://www.cnblogs.com/rock-roll/p/10763383.html){:target='\_blank'}
- [深入理解 Redux 中间件](https://www.jianshu.com/p/ae7b5a2f78ae){:target='\_blank'}
- [Redux 入门教程（二）：中间件与异步操作](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html){:target='\_blank'}
- [Mobx 思想的实现原理，及与 Redux 对比](https://zhuanlan.zhihu.com/p/25585910){:target='\_blank'}
- [Redux 从设计到源码](https://tech.meituan.com/2017/07/14/redux-design-code.html){:target='\_blank'}

## 抽象语法树(AST)

ESLint 使用 Espree 来解析 JavaScript 语句，生成 AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。

- [AST 抽象语法树——最基础的 javascript 重点知识，99%的人根本不了解](https://segmentfault.com/a/1190000016231512){:target='\_blank'}
- [AST 生成](https://astexplorer.net/){:target='\_blank'}
- [Parser API](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API){:target='\_blank'}
- [Espree](https://github.com/eslint/espree/blob/master/README.md){:target='\_blank'}
- [Esprima](https://esprima.org/index.html){:target='\_blank'}
- [代码规范工具及背后技术设计（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99b2e5ccb24267c1d01a14){:target='\_blank'}

## 工具背后的技术原理和设计

ESLint 使用 Espree 来解析 JavaScript 语句，生成 AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。

ESLint 的灵魂是每一条 rule，每条规则都是独立且插件化的。一条规则就是一个 node 模块，它由 meta 和 create 组成。meta 包含了该条规则的文档描述，相对简单。而 create 接受一个 context 参数，返回一个对象。从 context 对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。

- [代码规范工具及背后技术设计（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99b2e5ccb24267c1d01a14){:target='\_blank'}
- [Espree](https://github.com/eslint/espree/blob/master/README.md){:target='\_blank'}
- [Esprima](https://esprima.org/index.html){:target='\_blank'}
- [Selectors - ESLint - Pluggable JavaScript linter](https://eslint.org/docs/developer-guide/selectors){:target='\_blank'}

## 观察者模式 vs 发布订阅模式

&emsp;&emsp;设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

&emsp;&emsp;1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF 设计模式」。

&emsp;&emsp;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的**解决方案**。通俗一点说，**设计模式是在某种场合下对某个问题的一种解决方案**。如果再通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。

&emsp;&emsp;这些“好的设计”并不是谁发明的，而是早已存在于软件开发中。一个稍有经验的程序员**也许在不知不觉中数次使用过这些设计模式**。GoF（Gang of Four–四人组，《设计模式》几位作者）最大的功绩是把这些“好的设计”从浩瀚的面向对象世界中挑选出来，并且给予它们一个好听又好记的名字。

&emsp;&emsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案，他不是一个死的机制，他是一种思想，一种写代码的形式。

```html
<!DOCTYPE html>
<html lang="cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>发布订阅模式</title>
  </head>
  <body>
    <script>
      // 事件触发器
      class EventEmitter {
        constructor() {
          // { 'click': [fn1, fn2], 'change': [fn] }
          this.subs = Object.create(null);
        }

        // 注册事件
        $on(eventType, handler) {
          this.subs[eventType] = this.subs[eventType] || [];
          this.subs[eventType].push(handler);
        }

        // 触发事件
        $emit(eventType) {
          if (this.subs[eventType]) {
            this.subs[eventType].forEach((handler) => {
              handler();
            });
          }
        }
      }

      // 测试
      let em = new EventEmitter();
      em.$on('click', () => {
        console.log('click1');
      });
      em.$on('click', () => {
        console.log('click2');
      });

      em.$emit('click');
    </script>
  </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>观察者模式</title>
  </head>
  <body>
    <script>
      // 发布者-目标
      class Dep {
        constructor() {
          // 记录所有的订阅者
          this.subs = [];
        }
        // 添加订阅者
        addSub(sub) {
          if (sub && sub.update) {
            this.subs.push(sub);
          }
        }
        // 发布通知
        notify() {
          this.subs.forEach((sub) => {
            sub.update();
          });
        }
      }
      // 订阅者-观察者
      class Watcher {
        update() {
          console.log('update');
        }
      }

      // 测试
      let dep = new Dep();
      let watcher = new Watcher();

      dep.addSub(watcher);

      dep.notify();
    </script>
  </body>
</html>
```

&emsp;&emsp;观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。【订阅报纸】

&emsp;&emsp;其实 24 种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。【微博、专栏关注】

观察者模式和发布订阅模式有什么区别？

- 观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

- 发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。**观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。**

从表面上看：

- 观察者模式里，只有两个角色 —— 观察者 + 被观察者
- 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人 Broker

往更深层次讲：

- 观察者和被观察者，是松耦合的关系
- 发布者和订阅者，则完全不存在耦合

从使用层面上讲：

- 观察者模式，多用于单个应用内部
- 发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件

- [译 - 观察者模式 vs 发布订阅模式](https://zhuanlan.zhihu.com/p/51357583){:target='\_blank'}
- [发布订阅模式与观察者模式](https://blog.csdn.net/hf872914334/article/details/88899326){:target='\_blank'}
- [JAVA 设计模式总结之 23 种设计模式](https://www.cnblogs.com/pony1223/p/7608955.html){:target='\_blank'}【多 UML 结构图，推荐】
- [Java 设计模式：23 种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/){:target='\_blank'}【多 UML 结构图，推荐】

## webpack 插件原理

- [webpack 插件原理](https://blog.zfanw.com/how-webpack-plugin-works/)
- [揭秘 webpack 插件的工作原理](https://segmentfault.com/a/1190000023016347)
- [🔥Webpack 插件开发如此简单！](https://juejin.cn/post/6844904070868631560)
- [webpack 插件机制之 Tapable](https://juejin.cn/post/6844903774645911566)
- [Webpack 常见插件原理分析](https://www.jianshu.com/p/108d07de0e01)

## Webpack 热更新实现原理分析

- [Webpack 热更新实现原理分析](https://zhuanlan.zhihu.com/p/30623057)

## 前端路由

- [[实践系列] 前端路由](https://juejin.cn/post/6844903759458336776)
- [前端路由简介以及 vue-router 实现原理](https://zhuanlan.zhihu.com/p/37730038){:target='\_blank'}

## Babel 原理

- [[实践系列]Babel 原理](https://juejin.cn/post/6844903760603398151)
- [一口（很长的）气了解 babel](https://zhuanlan.zhihu.com/p/43249121){:target='\_blank'}
- [你不知道的 Babel（7000 字，详解原理并手写插件）](https://my.oschina.net/u/4088983/blog/4545928){:target='\_blank'}

## 浏览器缓存机制

- [实践这一次,彻底搞懂浏览器缓存机制](https://juejin.cn/post/6844903764566999054)

## Nginx

- [前端开发者必备的 nginx 知识](https://segmentfault.com/a/1190000018454271)
- [Nginx 极简教程 — 帮助新手快速入门](https://mp.weixin.qq.com/s/KXXPz2CY_8f_nedHijYi9w){:target='\_blank'}

## Linux

- [前端&后端程序员必备的 Linux 基础知识](https://www.cnblogs.com/kkdn/p/9295039.html)
- [前端 linux 基础，这一篇就够了](https://juejin.cn/post/6844903801283952653){:target='\_blank'}
- [使用 linux 发布前端项目](https://xiaozhuanlan.com/topic/1956032748){:target='\_blank'}
- [前端应该掌握的 linux 命令和工具](https://segmentfault.com/a/1190000010421178){:target='\_blank'}

## ajax 跨域，这应该是最全的解决方案了

```js
let url = 'xxx?data=' + JSON.stringify(data);
let img = new Image();
img.src = url;
```

- [ajax 跨域，这应该是最全的解决方案了](https://segmentfault.com/a/1190000012469713){:target='\_blank'}

## Build your own React

- [Build your own React](https://pomb.us/build-your-own-react/){:target='\_blank'}

## React 性能的飞跃 —— Fiber

<!-- 如果是技术分享，建议叫：XX个问题助你理解 Fiber -->

从 v15 到 v16，React 团队花了两年时间将源码架构中的 Stack Reconciler 重构为 Fiber Reconciler。

- React15 的痛点 与 Concurrent Mode（并发模式）
  - Concurrent Mode 的目的是实现一套可中断/恢复的更新机制。其由两部分组成：
    - 一套协程架构：Fiber Reconciler
    - 基于协程架构的启发式更新算法：控制协程架构工作方式的算法
- requestIdleCallback
- React16 的启发式更新算法
- React17 启发式更新算法
  > React16 的 expirationTimes 模型只能区分是否>=expirationTimes 决定节点是否更新。React17 的 lanes 模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。

<!--  -->

- [React Fiber Architecture](https://github.com/acdlite/react-fiber-architecture){:target='\_blank'}
- [React Fiber 架构](https://zhuanlan.zhihu.com/p/37095662){:target='\_blank'}
- [React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127){:target='\_blank'}
- [前端工程师的自我修养：React Fiber 是如何实现更新过程可控的](https://www.zoo.team/article/about-react-fiber){:target='\_blank'}
- [React Fiber 是什么](https://zhuanlan.zhihu.com/p/26027085){:target='\_blank'}
- [A deep dive into React Fiber internals](https://blog.logrocket.com/deep-dive-into-react-fiber-internals/){:target='\_blank'}
- [React 的新引擎—React Fiber 是什么？](https://www.infoq.cn/article/what-the-new-engine-of-react/)
- [React17 新特性：启发式更新算法](https://zhuanlan.zhihu.com/p/182411298){:target='\_blank'}
- [以 React 为例，说说框架和性能（下）](https://gitbook.cn/m/mazi/columns/5c91c813968b1d64b1e08fde/topics/5cbbf49bbbbba80861a35c64){:target='\_blank'}
- [Facebook 将对 React 的优化实现到了浏览器！](https://mp.weixin.qq.com/s/IiHmU2kLQgmNRkf3H66MdQ){:target='\_blank'}

- [你应该知道的 requestIdleCallback](https://segmentfault.com/a/1190000014457824){:target='\_blank'}
- [新兴前端框架 Svelte 从入门到原理](https://zhuanlan.zhihu.com/p/350507037){:target='\_blank'}

## React

- [传送门：React Portal](https://zhuanlan.zhihu.com/p/29880992){:target='\_blank'}
- [React.createPortal 及 Modal 的新实现方式](http://www.ptbird.cn/react-portal-createPortal.html){:target='\_blank'}
- [ReactDOM.render 和 ReactDOM.createPortal 的简单理解和区别](https://www.gjwei.com/article/31){:target='\_blank'}
- [面试题：谈谈 Vue 和 React 的区别？](https://mp.weixin.qq.com/s/15HcPt1U48v6DhLAL3SZIg){:target='\_blank'}

## loader 插件 npm 包 自动化构建工具

## 单点登录

- [登录系统实现](https://juejin.cn/post/6937970750984814622){:target='\_blank'}
- [面试官：什么是单点登录？如何实现？](https://mp.weixin.qq.com/s/8qJt8i_DSXY5zDh2ir_2gw){:target='\_blank'}
- [【大前端】认识单点登录](https://www.cnblogs.com/yexiaochai/p/4422460.html){:target='\_blank'}
- [前端关于单点登录的知识](https://blog.csdn.net/juoduomade/article/details/82025715){:target='\_blank'}
- [什么是单点登录(原理与实现简介)](https://blog.csdn.net/xiaoguan_liu/article/details/91492110){:target='\_blank'}
- [使用 JWT 实现单点登录（完全跨域方案）](https://blog.csdn.net/weixin_42873937/article/details/82460997){:target='\_blank'}
- [阿里 P8 架构师谈：单点登录的原理、来源、实现、以及技术方案比较](https://youzhixueyuan.com/the-principle-implementation-and-technical-scheme-of-single-sign-on.html){:target='\_blank'}
- [单点登录终极方案之 CAS 应用及原理](https://zhuanlan.zhihu.com/p/94515582){:target='\_blank'}
- [单点登录的原理](https://www.cnblogs.com/lexiaofei/p/7172214.html){:target='\_blank'}
- [一篇文章彻底弄懂 CAS 实现 SSO 单点登录原理](https://www.cnblogs.com/wangsongbai/p/10299655.html){:target='\_blank'}
- [CAS 单点登录原理（包含详细流程，讲得很透彻，耐心看下去一定能看明白！）](https://blog.csdn.net/ban_tang/article/details/80015946){:target='\_blank'}

## 登录认证

- [前端应该学习的 Token 登录认证知识](https://mp.weixin.qq.com/s/-Jt9Af20_vgYrpvtbTatPQ){:target='\_blank'}

## 邮件服务

- [Node 后台邮件服务器](https://blog.csdn.net/konghouy/article/details/84961500){:target='\_blank'}
- [Nodejs 搭建邮件自动发送服务](https://blog.csdn.net/yihanzhi/article/details/79628574){:target='\_blank'}

## 性能优化

- [《记忆化技术 memoize-one》](https://liyang0207.github.io/2018/10/11/%E3%80%8A%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AFmemoize-one%E3%80%8B/){:target='\_blank'}
- [性能优化问题，老司机如何解决（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99c858ccb24267c1d01bd6){:target='\_blank'}【文末链接】
- [7000 字前端性能优化总结](https://mp.weixin.qq.com/s/JoX9I544S7Q4U4ROkGqbgw){:target='\_blank'}

## 前端微服务

- [可能是你见过最完善的微前端解决方案](https://tech.antfin.com/community/articles/536){:target='\_blank'}
- [面向大型工作台的微前端解决方案 icestark](https://zhuanlan.zhihu.com/p/88449415){:target='\_blank'}
- [icestark - 简单而友好的前端研发体系](https://ice.work/){:target='\_blank'}
- [万字长文+图文并茂+全面解析微前端框架 qiankun 源码 - qiankun 篇](https://blog.csdn.net/mingyuanyunlian/article/details/108766703){:target='\_blank'}
- [微前端架构实战](https://www.zhihu.com/search?type=content&q=%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98){:target='\_blank'}

## serverless

## 低代码开发平台

- [百度低代码 amis](){:target='\_blank'}：amis 是一个低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率：[文档](https://baidu.gitee.io/amis/zh-CN/docs/index){:target='\_blank'} &#124; [GitHub](https://github.com/baidu/amis){:target='\_blank'}。
- [前端页面可视化搭建工具业界的轮子](https://juejin.cn/post/6858881797490098190){:target='\_blank'}
- [前端服务化——页面搭建工具的死与生](https://www.cnblogs.com/sskyy/p/6496287.html){:target='\_blank'}
- [基于现代的前端框架，为什么没有成熟的支持控件拖拽布局，并可以自动生成前端代码的设计器出现？](https://www.zhihu.com/question/338929219){:target='\_blank'}

## GraphQL

- [记一次 GraphQL 真正的详细入门：原生、koa2、的实战分享会](https://segmentfault.com/a/1190000023017476){:target='\_blank'}
- [如何在纯 JavaScript 中使用 GraphQL](https://mp.weixin.qq.com/s/LYwpQkJepoS6outzggiwqg){:target='\_blank'}

## Immutable Data

Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 **Persistent Data Structure（持久化数据结构）**，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 **Structural Sharing（结构共享）**，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

Immutable.js 持久化数据结构的基本实现原理：

- 核心数据结构 Vector Trie。位分区机制：采用位分区的根本原因是为了优化速度；
- 对于空间的优化： Immutable.js 参考了 HAMT（hash array mapped trie）对树进行了高度和节点内部的压缩，此外，还对操作效率进行了其它一些优化。

- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3){:target='\_blank'}【图】
- [深入探究 immutable.js 的实现机制（一）](https://zhuanlan.zhihu.com/p/44571842){:target='\_blank'}
- [深入探究 immutable.js 的实现机制（二）](https://zhuanlan.zhihu.com/p/45106741){:target='\_blank'}
- [Functional Go: 持久化数据结构简介](https://io-meter.com/2016/09/03/Functional-Go-persist-datastructure-intro/){:target='\_blank'}

## SEO 优化

[第一、二、三、四代搜索引擎分别指什么，对应网站分别有哪些？](https://zhidao.baidu.com/question/229530305.html)
[第四代搜索引擎前沿综述](https://wenku.baidu.com/view/16418bec4afe04a1b071de0b.html)

> [SEO 算法](https://www.ainiseo.com/category/suanfa)

> [谷歌 SEO](https://www.ainiseo.com/category/google-seo)

> [SEO 算法](http://www.sclangge.com/suanfa/)

- https://www.kuanxu.com/seo/39.html
- https://wiki.jikexueyuan.com/project/seo/37.html
- https://juejin.cn/post/6844903824428105735
- https://github.com/cisen/blog/issues/570
- https://lusongsong.com/reed/7657.html

- Prerender 预渲染优化 SEO：https://github.com/prerender/prerender
- https://love.fishman.wang/2016/05/06/prerender%E9%A2%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96SEO/

- https://blog.naibabiji.com/google-seo

- https://static.googleusercontent.com/media/www.google.com/zh-CN//intl/zh-CN/webmasters/docs/search-engine-optimization-starter-guide-zh-cn.pdf

- https://prerender.io/

- https://blog.csdn.net/zai_xia/article/details/86697300
- https://deliverr.com/zh/blog/shopify-seo/

## BFC

BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

- [BFC 背后的布局问题](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbeaf5bbbba80861a35c03)
- [10 分钟理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)

## 饱受诟病的原型继承有什么优势？

- [类继承和原型继承的区别](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbe961bbbba80861a35bfd)
- [征服 JavaScript 面试：类继承和原型继承的区别](https://mp.weixin.qq.com/s/CqXmu4n6aZsqB-jJ0O0t-g)

## 如何实现用户行为的动态采集与分析

- [如何实现用户行为的动态采集与分析](https://www.zoo.team/article/user-data-analysis){:target='\_blank'}

## 前端灾备 —— 容灾和恢复

- [容错，高可用和灾备](http://www.ruanyifeng.com/blog/2019/11/fault-tolerance.html)
- [前端容灾](https://juejin.cn/post/6844903623722287117)
- [【灾备知识总结】容灾与备份区别、灾备技术、容灾体系规划](http://www.cfdzsw.com/2019/09/07/%e3%80%90%e7%81%be%e5%a4%87%e7%9f%a5%e8%af%86%e6%80%bb%e7%bb%93%e3%80%91%e5%ae%b9%e7%81%be%e4%b8%8e%e5%a4%87%e4%bb%bd%e5%8c%ba%e5%88%ab%e3%80%81%e7%81%be%e5%a4%87%e6%8a%80%e6%9c%af%e3%80%81%e5%ae%b9/)
- [浅谈容灾测试](https://www.cnblogs.com/imyalost/p/8290567.html)
- [前端网站容灾-CDN 主域重试方案](https://www.sohu.com/a/396397337_495695)
- [从“挖光缆”到“剪网线”|蚂蚁金服异地多活单元化架构下的微服务体系](https://juejin.cn/post/6844903705783828488)

## 灰度发布 和 A/B testing

- [一种前端灰度发布方案](https://www.cnblogs.com/lvdabao/p/11920919.html)
- [手把手教你搭建一个灰度发布环境](https://segmentfault.com/a/1190000022612488)
- [基于 Nodejs 的前端灰度发布方案](https://segmentfault.com/a/1190000018337322)
- [蓝绿部署、A/B 测试以及灰度发布](https://segmentfault.com/a/1190000008542092) &#124; [译](https://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/)
- [微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布](https://www.jianshu.com/p/022685baba7d)
- [要进大厂？前端灰度发布必须要知道](https://juejin.cn/post/6844903969110622222)
- [Regal 灰度发布智能分组引擎](https://segmentfault.com/a/1190000009867597)
- [基于 Nginx+lua+Memcache 实现灰度发布](https://segmentfault.com/a/1190000022834145)
- [前端灰度-前端项目如何进行灰度？](https://juejin.cn/post/6897090555868610574)
- [灰度部署、滚动部署与蓝绿部署](https://juejin.cn/post/6844903821173325838)
- [灰度发布-上线前的最后一公里](https://juejin.cn/post/6844903614910038030)

## CI/CD:

- https://blog.didiyun.com/index.php/2018/11/14/gitlab-cicd/
- https://www.cnblogs.com/jserhub/p/12888316.html
- https://docs.gitlab.com/ee/ci/README.html
- https://www.cnblogs.com/jserhub/p/12941318.html
- https://developer.51cto.com/art/202011/631123.htm
- [GitLab CI/CD 基础教程（一）](https://blog.stdioa.com/2018/06/gitlab-cicd-fundmental/){:target='\_blank'}
- [CI/CD 是什么？如何理解持续集成、持续交付和持续部署](https://www.redhat.com/zh/topics/devops/what-is-ci-cd){:target='\_blank'}
- [Serverless 掀起新的前端技术变革](https://zhuanlan.zhihu.com/p/65914436){:target='\_blank'}
- [Serverless——前端的 3.0 时代](https://zhuanlan.zhihu.com/p/84054729){:target='\_blank'}

## 性能数据获取：window.performance 与 自定义时间计算

- [fmp-timing](https://github.com/qbright/fmp-timing){:target='\_blank'} &#124; [前端监控实践——FMP 的智能获取算法](https://segmentfault.com/a/1190000017092752){:target='\_blank'}
- [性能监控和错误收集与上报（上）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99c52fccb24267c1d01b87){:target='\_blank'}
- [初探 performance – 监控网页与程序性能](http://www.alloyteam.com/2015/09/explore-performance/){:target='\_blank'}
- JS 在线代码片段性能测试工具

  - [https://jsperf.com](https://jsperf.com){:target='\_blank'}（目前已不可用）
  - [https://jsbench.me/](https://jsbench.me/){:target='\_blank'}
  - [Benchmark.js](https://www.npmjs.com/package/benchmark)：A robust benchmarking library that supports

- [JSPerf-javascript 代码性能测试利器](https://blog.csdn.net/dpj514/article/details/78767936){:target='\_blank'}

## 性能优化

## 服务端渲染(SSR)

&emsp;&emsp;SSR 对于大部分场景最主要是考虑到两点：提高首屏加载速度 和 方便 SEO。

### 概念解析

&emsp;&emsp;服务端渲染（Server-Side Rendering），是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。
&emsp;&emsp;简单理解是将组件或页面通过服务器**生成 html 字符串，再发送到浏览器**，最后将静态标记"混合"为客户端上完全可交互的应用程序。

- 没使用服务渲染时，当请求 index.html 页面时，返回的 body 里为空，之后执行 js 将 html 结构注入到 body 里，再结合 css 显示出来；
- 使用了服务端渲染，当请求 index.html 页面时，返回的 body 里已经有了首屏的 html 结构，之后结合 css 显示出来。

### SSR 的利弊

- 优势
  - 更利于 SEO。不同爬虫工作原理类似，大部分爬虫只会爬取源码，不会执行网站的任何脚本。
  - 更利于首屏渲染。首屏的渲染是 node 发送过来的 html 字符串，并不依赖于 js 文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。
  - 在服务端完成数据请求比在浏览器端效率要高。
  - 禁用了 JavaScript 的浏览器依然可以展示出服务端渲染的静态页面。
- 不足
  - 高并发访问的情况，会大量占用服务端 CPU 资源，服务端压力较大；
  - 开发条件受限，比如在服务端渲染中，只会执行到 render 及之前的生命周期钩子（组件没有被完整地“渲染”出来）；
  - 学习成本相对较高.除了对 webpack、React 要熟悉，还需要掌握 node、Koa2 等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。当然，现在也可以直接使用[Next.js](https://www.nextjs.cn/)和[Nuxt.js](https://www.nuxtjs.cn/)等 SSR 解决方案。

### React 服务端渲染 相关 API 及 主要原理

- `renderToString`：对于服务端，通过调用`ReactDOMServer.renderToString`方法把 Virtual DOM 转换成 HTML 字符串返回给客户。`renderToString` 的功能是一口气同步产生最终 HTML，如果 React 组件树很庞大，这样一个同步过程可能比较耗时。
- `renderToNodeStream`：`renderToNodeStream` 把渲染结果以“流”的形式塞给 response 对象（这里的 response 是 express 或者 koa 的概念），这意味着不用等到所有 HTML 都渲染出来了才给浏览器端返回结果；
- [`hydrate`](http://www.ayqy.net/blog/ssr-hydrate/)：React v16 之后用 `React.hydrate` 替换 `React.render`，这个 [`hydrate` 就是“注水”](https://www.zhihu.com/question/66068748){:target='\_blank'}，[render !== hydrate](https://zhuanlan.zhihu.com/p/33887159){:target='\_blank'}。`hydrate()`配合 SSR 使用，与`render()`的区别在于渲染过程中能够复用服务端返回的现有 HTML 节点，只为其附加交互行为（事件监听等），并不重新创建 DOM 节点。

### 同构应用

&emsp;&emsp;一套代码既可以在服务端运行又可以在客户端运行，**在服务器端执行一次，用于实现服务器端渲染**，**在客户端再执行一次，用于接管页面交互**，这就是同构应用。简而言之, 就是服务端直出和客户端渲染的组合, 能够充分结合两者的优势，并有效避免两者的不足。

### 资料精华荟萃

- 原理：[浅谈服务端渲染(SSR)](https://www.jianshu.com/p/10b6074d772c) &#124; [React SSR 之 API 篇](http://www.ayqy.net/blog/react-ssr-api/) &#124; [React SSR 之原理篇](http://www.ayqy.net/blog/react-ssr-under-the-hood/) &#124; [React SSR 中的 hydrate 是什么意思？](http://www.ayqy.net/blog/ssr-hydrate/)
- 实践：[彻底理解 React 之 React SSR、React 服务端渲染，教你从零搭建配置](https://www.jianshu.com/p/47c8e364d0bc)
- 进阶：[一文吃透 React SSR 服务端渲染和同构原理](https://segmentfault.com/a/1190000020417285)
- 视频资料推荐：[React 服务器渲染原理解析与实践](https://coding.imooc.com/class/chapter/276.html)

## 安全和风险控制 —— 防攻击

## 前端自动化测试

- [京喜前端自动化测试之路](https://juejin.cn/post/6844904150631710727)

## Web Components

- html 很宽松，浏览器也可以识别不规则、不合法标签（元素）（如`<custom-label>Web Components</custom-label>` 会展示"Web Components"。）；
- 自定义继承自`HTMLElement`的类，称为自定义元素的类；
- 经过`window.customElements.define`API 定义和注册自定义元素，使得**不合法标签**（自定义元素）与自定义元素的类关联，实现**合法化**；
- 通过模板标签`<template>`简化类的定义过程并添加样式；
- 通过自定义元素的`attachShadow()`方法开启 Shadow DOM（这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部），隐藏自定义元素的内部实现；
- 添加事件监听、进行组件化封装等。

> 参考资料：[Web Components 入门实例教程-阮一峰](http://www.ruanyifeng.com/blog/2019/08/web_components.html){:target='\_blank'} &#124; [Window.customElements](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/customElements){:target='\_blank'} &#124; [Web Components](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components){:target='\_blank'}

## 正则表达式

- [JS 正则表达式完整教程（略长）](https://juejin.cn/post/6844903487155732494){:target='\_blank'}

## 算法

- [前端该如何准备数据结构和算法？](https://segmentfault.com/a/1190000020122791)
- [面试助力，算法 101：JavaScript 描述](https://101.zoo.team/)
- [awesome-coding-js](http://www.conardli.top/docs/)

## VSCode 插件开发

- [VSCode 插件开发全攻略（一）概览](http://blog.haoji.me/vscode-plugin-overview.html){:target='\_blank'}
- [VSCode 插件开发入门](https://zhuanlan.zhihu.com/p/99198980){:target='\_blank'}
- [vscode-extension-samples](https://github.com/microsoft/vscode-extension-samples){:target='\_blank'}【Hello World Minimal Sample 为 JS 版；helloworld-sample 为 TS 版】
- [Your First Extension](https://code.visualstudio.com/api/get-started/your-first-extension){:target='\_blank'}
- [Extension Anatomy](https://code.visualstudio.com/api/get-started/extension-anatomy){:target='\_blank'}
- [VS Code 插件开发介绍（一）](https://segmentfault.com/a/1190000016641617){:target='\_blank'}

## Chrome 插件(扩展)开发

- [【干货】Chrome 插件(扩展)开发全攻略](http://blog.haoji.me/chrome-plugin-develop.html){:target='\_blank'} &#124; [博客园](https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html){:target='\_blank'}
- [Console Importer](https://github.com/pd4d10/console-importer/blob/master/app/scripts.babel/importer.js){:target='\_blank'}

## Draft.js 与富文本编辑器

- [Draft.js 在知乎的实践](https://zhuanlan.zhihu.com/p/24951621){:target='\_blank'}
- [深入浅出 contenteditable 富文本编辑器](https://zhuanlan.zhihu.com/p/37051858){:target='\_blank'}

## 前端水印

- [Nodejs 给图片批量添加水印](https://blog.csdn.net/qq_37746855/article/details/114254025){:target='\_blank'} &#124; [node-images](https://github.com/zhangyuanwei/node-images){:target='\_blank'}
  - [Web 前端水印方案](https://zhuanlan.zhihu.com/p/111331319){:target='\_blank'}
  - **[前端水印生成方案(网页水印+图片水印)](https://juejin.cn/post/6844903645155164174){:target='\_blank'}** &#124; [jimp](https://github.com/oliver-moran/jimp){:target='\_blank'} &#124; [gm](https://github.com/aheckmann/gm){:target='\_blank'}
  - [不能说的秘密——前端也能玩的图片隐写术](http://www.alloyteam.com/2016/03/image-steganography/){:target='\_blank'}

## 前端技术浪潮

- **[2020 年前端技术浪潮与应用](https://blog.csdn.net/LittleRoundFace/article/details/110285181){:target='\_blank'}** &#124; [掘金](https://juejin.cn/post/6894983076217257991){:target='\_blank'} &#124; [微信链接](https://mp.weixin.qq.com/s/PskcaYXDPwYagNlqosVmQw){:target='\_blank'}
- [你应该知道的前端技术浪潮与应用](https://king-hcj.github.io/2021/04/28/front-end-technology-and-application/){:target='\_blank'}

## 可视化

- [页面可视化搭建工具前生今世](https://zhuanlan.zhihu.com/p/37171897){:target='\_blank'}
- [基于 React 的可视化编辑平台实践](https://zhuanlan.zhihu.com/p/94016600){:target='\_blank'}
- [可视化搭建前端工程 - 阿里飞冰了解一下](https://zhuanlan.zhihu.com/p/41416320){:target='\_blank'}
- [Web 前端可视化绘图软件编辑器](https://blog.csdn.net/qq_41646249/article/details/106278125){:target='\_blank'}
- [慕课-可视化编辑](https://www.imooc-lego.com/){:target='\_blank'} &#124; [Web 前端架构师](https://class.imooc.com/sale/fearchitect){:target='\_blank'}

## Puppeteer

&emsp;&emsp;Puppeteer 是一个 node 库，他提供了一组用来操纵 Chrome 的 API, 通俗来说就是一个 headless chrome 浏览器 (当然你也可以配置成有 UI 的，默认是没有的)。既然是浏览器，那么我们手工可以在浏览器上做的事情 Puppeteer 都能胜任, 另外，Puppeteer 翻译成中文是”木偶”意思，所以听名字就知道，操纵起来很方便，你可以很方便的操纵她去实现：

1） 生成网页截图或者 PDF
2） 高级爬虫，可以爬取大量异步渲染内容的网页
3） 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试
4） 捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题

&emsp;&emsp;Puppeteer 跟 webdriver 以及 PhantomJS 最大的 的不同就是它是站在用户浏览的角度，而 webdriver 和 PhantomJS 最初设计就是用来做自动化测试的，所以它是站在机器浏览的角度来设计的，所以它们 使用的是不同的设计哲学。

### 坑点

- Cannot find module ‘puppeteer/DeviceDescriptors‘

  - [解决：Error: Cannot find module ‘puppeteer/DeviceDescriptors‘ 问题](https://blog.csdn.net/weixin_38190633/article/details/108663172){:target='\_blank'}
  - [DeviceDescriptors.ts](https://github.com/puppeteer/puppeteer/blob/main/src/common/DeviceDescriptors.ts){:target='\_blank'}
  - 解决：`await page.emulate(puppeteer.devices['iPhone 6']);`

- Page.printToPDF 操作一定要在无头模式下进行，有头模式无法调用。
- Puppeteer 浏览器窗口大小 window size 设置方法：

  - 通过 browser 对象参数的 defaultViewport 设置无法改变浏览器窗口大小
  - 使用 page 的 page.setViewport()方法也无效
  - 只能使用 browser 对象的 args: [`--window-size=800,800`]参数设置

- [puppeteer](https://github.com/puppeteer/puppeteer/){:target='\_blank'}
- [Puppeteer 入门教程](https://www.r9it.com/20171106/puppeteer.html){:target='\_blank'}
- [API 文档](https://github.com/puppeteer/puppeteer/blob/main/docs/api.md){:target='\_blank'}

- [网站性能测试利器:Puppeteer](https://cloud.tencent.com/developer/article/1086109){:target='\_blank'}
- [结合项目来谈谈 Puppeteer](https://zhuanlan.zhihu.com/p/76237595){:target='\_blank'}

## 小程序

- **[微信小程序开发实践总结](https://mp.weixin.qq.com/s/U23qtQz301MoNsd-pooQHw){:target='\_blank'}** &#124; [博文地址](http://interview.poetries.top/principle-docs/comprehensive/10-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.html){:target='\_blank'}

## shell 脚本编程

- [Bash 脚本教程](https://wangdoc.com/bash/index.html){:target='\_blank'}
- [shell 编程 100 例](https://blog.csdn.net/yugemengjing/article/details/82469785){:target='\_blank'}

## 混合开发

- [Hybrid APP 基础篇(四)->JSBridge 的原理](https://www.cnblogs.com/dailc/p/5931324.html){:target='\_blank'}
- [JSBridge 的原理及使用](https://blog.csdn.net/yuzhengfei7/article/details/93468914){:target='\_blank'}
- [H5 与 Native 交互之 JSBridge 技术](https://segmentfault.com/a/1190000010356403){:target='\_blank'}
- **[WebView 库功能完善](https://www.jianshu.com/p/6f65ab29ef5d){:target='\_blank'}**
- **[YCWebView](https://github.com/yangchong211/YCWebView/wiki){:target='\_blank'}**
- [史上最全 WebView 使用，附送 Html5Activity 一份](https://www.jianshu.com/p/3fcf8ba18d7f){:target='\_blank'}
- [Android 弹出软键盘 android:windowSoftInputMode 设置总结](https://blog.csdn.net/suyimin2010/article/details/80906649){:target='\_blank'}

- https://zhuanlan.zhihu.com/p/58691238
- https://blog.csdn.net/lowprofile_coding/article/details/77928614
- https://blog.csdn.net/carson_ho/article/details/52693322
- https://www.jianshu.com/p/d2f5ae6b4927
- https://www.runoob.com/w3cnote/android-tutorial-webview.html

## CSS 动画 与 前端交互

- [joshwcomeau 博客](https://www.joshwcomeau.com/){:target='\_blank'}
- [Web 开发者的终极备忘清单（建议收藏）](https://mp.weixin.qq.com/s/EreGMtfXKFPKXssMBv1krg){:target='\_blank'}

- ✨[An Interactive Guide to CSS Transitions](https://www.joshwcomeau.com/animation/css-transitions/){:target='\_blank'}
- [Using the Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API#moving_it_to_javascript){:target='\_blank'}
- [Animation.currentTime](https://developer.mozilla.org/zh-CN/docs/Web/API/Animation/currentTime){:target='\_blank'}
- [CSS3（三）Animation 入门详解](https://blog.csdn.net/u013243347/article/details/79976352){:target='\_blank'}
- [Web 技巧（14）](https://zhuanlan.zhihu.com/p/73590322){:target='\_blank'}
- [animation](https://developer.mozilla.org/en-US/docs/Web/CSS/animation){:target='\_blank'}
- [animation](https://css-tricks.com/almanac/properties/a/animation/){:target='\_blank'}
- [CSS 动画和变换的详细指南](https://www.jianshu.com/p/9235fdfeb1ae){:target='\_blank'}
- [前端常见动画实现原理](https://juejin.cn/post/6896115251239092232){:target='\_blank'}
- [你知道几种前端动画的实现方式？](https://zhuanlan.zhihu.com/p/269213649){:target='\_blank'}
- [前端动画](https://lucifer.ren/animation/#/){:target='\_blank'}
- [最全的动效落地方法（上篇）：在界面设计中，好动效是什么样的？](http://www.woshipm.com/ucd/982907.html){:target='\_blank'}
- [最全的动效落地方法（下篇）：从前端的角度来讲，有哪些便捷的方法实现这些动效？](http://www.woshipm.com/ucd/982993.html){:target='\_blank'}
- [怎么实现一个 3d 翻书效果](https://juejin.cn/post/6844903665216520206){:target='\_blank'}
- [一个纯 CSS3 实现的酷炫翻书效果](https://segmentfault.com/a/1190000006058721){:target='\_blank'}
- [全屏滚动效果 H5FullscreenPage.js](http://www.alloyteam.com/2015/04/quan-ping-gun-dong-xiao-guo-h5fullscreenpage-js/){:target='\_blank'}
- [使用 CSS offset-path 让元素沿着不规则路径运动](https://www.zhangxinxu.com/wordpress/2017/03/offset-path-css-animation/){:target='\_blank'}
- [探秘神奇的运动路径动画 Motion Path](https://segmentfault.com/a/1190000039916159){:target='\_blank'}
- [超级强大的 SVG SMIL animation 动画详解](https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/){:target='\_blank'}
- [SVG 轻松实现路径动画](https://xiaotianxia.github.io/blog/vuepress/css/svg_path_animation.html){:target='\_blank'}
- 掘金专栏

- [SCSS 教程，基础，日常用法](https://blog.csdn.net/KimBing/article/details/89738636){:target='\_blank'}
- [Sass 中文网](https://www.sass.hk/){:target='\_blank'}
- [aqua.css](https://aquacss.netlify.app/){:target='\_blank'}

- [HTML5/CSS3 3D 环形图片墙 伴随旋转动画](https://www.html5tricks.com/demo/html5-css3-3d-photo-slider/index.html){:target='\_blank'}
- [【前端制作】html+css 实现好看的三维手环动画](https://www.bilibili.com/video/BV19f4y1D7W1){:target='\_blank'}
- [使用 CSS3 实现转盘抽奖效果](https://blog.csdn.net/lujie_1996/article/details/79015667){:target='\_blank'}
- [用 CSS 实现一个抽奖转盘(附详细代码+思路)](https://blog.csdn.net/lgno2/article/details/111771997){:target='\_blank'}
- [CSS3 实现转盘抽奖](https://www.dazhuanlan.com/2020/03/20/5e73d6883310f/){:target='\_blank'}
- [css 轮播](http://www.bootstrapmb.com/tag/csslunbo){:target='\_blank'}
- [轮播特效](http://www.bootstrapmb.com/tag/lunbotexiao){:target='\_blank'}
- **[CSS 3.0 特效轮播图](https://blog.csdn.net/weixin_40629244/article/details/91127723){:target='\_blank'}**
- [HTML5/CSS3 超酷环形动画菜单](https://www.html5tricks.com/html5-css3-circle-menu.html){:target='\_blank'}
- [超简单! 一个标签搞定跑马灯，纯 css 制作跑马灯效果](https://blog.csdn.net/webjhh/article/details/115431915){:target='\_blank'}
- [css,js 实现跑马灯效果](https://blog.csdn.net/qq_36736346/article/details/80385007){:target='\_blank'}
- [CSS html 文字的跑马灯(流光)特效 ](https://www.feiniaomy.com/post/351.html){:target='\_blank'}
- [CSS3——3D 旋转图（跑马灯效果图）](https://www.cnblogs.com/2010master/p/5827258.html){:target='\_blank'}
- [跑马灯效果（css3,3d 变换）](https://blog.csdn.net/jinxi1112/article/details/52982021){:target='\_blank'}
- [HTML5 3D 相册图片轮播动画](https://www.html5tricks.com/html5-3d-gallery-animation.html){:target='\_blank'}
- [HTML5+CSS3 图片 3D 立体旋转切换轮播](http://www.internetke.com/effects/css3/2016/0529/1916.html){:target='\_blank'}
- [js+css3 图片 3D 旋转轮播](https://jingyan.baidu.com/article/495ba841bf301d38b20ede43.html){:target='\_blank'}
- [纯 CSS 交互式 3D 立方体轮播](https://www.jq22.com/jquery-info10650){:target='\_blank'}

- **[好吧，CSS3 3D transform 变换，不过如此！](https://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/){:target='\_blank'}**
- **[CSS3 transform 实现图片旋转木马 3D 浏览效果实例页面](https://www.zhangxinxu.com/study/201209/pictures-3d-slide-view.html){:target='\_blank'}**
- [carousel.html](https://github.com/Showingbun/nuomi/blob/master/carousel/carousel.html){:target='\_blank'}

- **[我写 CSS 的常用套路](https://zhuanlan.zhihu.com/p/107741668){:target='\_blank'}**
- **[我写 CSS 的常用套路·续](https://juejin.cn/post/6881546676188741645){:target='\_blank'}**
- [在轮播图里寻求新颖是不是搞错了什么](https://juejin.cn/post/6916678317736132615){:target='\_blank'}
- **[所有轮播图地址](https://codepen.io/collection/DQPRzJ){:target='\_blank'}**

- **[我的 CSS 不可能那么可爱](https://juejin.cn/column/6961384948099973133){:target='\_blank'}**

- **[请收下这 72 个炫酷的 CSS 技巧](https://juejin.cn/post/6844904031513477128){:target='\_blank'}**

- [CSS filter 与前端滤镜](https://zhuanlan.zhihu.com/p/125137964){:target='\_blank'}
- [CSS filter:hue-rotate 色调旋转滤镜实现按钮批量生产](https://www.zhangxinxu.com/wordpress/2018/11/css-filter-hue-rotate-button/){:target='\_blank'}
- [hue-rotate()](<https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate()>){:target='\_blank'}

- [Hammer.js 官网](http://hammerjs.github.io/){:target='\_blank'}
- [hammer.js GitHub](https://github.com/hammerjs/hammer.js){:target='\_blank'}
- [Hammer.js 中文教程（有 demo）](https://www.jianshu.com/p/0b0b9364f967/){:target='\_blank'}
- [hammer.js](https://www.bootcdn.cn/hammer.js/){:target='\_blank'}

- [Less 给 CSS 加点料](https://less.bootcss.com/){:target='\_blank'}

- [CSS3 3D transforms 系列教程-3D 旋转木马](http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201502061338.html){:target='\_blank'}
- [css3 白色质感 3D 按钮特效](http://www.htmleaf.com/css3/ui-design/201912025854.html){:target='\_blank'}
- **[jQuery 之家——自由分享 jQuery、html5 和 css3 的插件库](http://www.htmleaf.com/){:target='\_blank'}**

- Loading 的统一和个性化:文字、类 logo 文字的跳跃效果
- 进度条优化
- tootips 优化
- 跑马灯的 css 实现，移除 swiper，服务端预请求

## canvas

- [基于 html2canvas 实现网页保存为图片及图片清晰度优化](https://segmentfault.com/a/1190000011478657){:target='\_blank'}
- [一次 H5 「保存页面为图片」 的踩坑之旅](https://juejin.cn/post/6844903513848283143){:target='\_blank'}
- [html2canvas](https://html2canvas.hertzen.com/){:target='\_blank'}
- [移动端 H5 页面生成图片解决方案](https://segmentfault.com/a/1190000015914238){:target='\_blank'}
- [H5 中 html 页面存为图片并长按 保存](https://www.cnblogs.com/autumn123/p/9606451.html){:target='\_blank'}
- [学习 HTML5 Canvas 这一篇文章就够了](https://www.runoob.com/w3cnote/html5-canvas-intro.html){:target='\_blank'}

## Web 也要在 GPU 并行计算中分一杯羹？

- [Web 也要在 GPU 并行计算中分一杯羹？](https://yrq110.me/post/front-end/try-gpu-operations-in-web/){:target='\_blank'}

## Software Architecture

- [Delft Students on Software Architecture: DESOSA 2018](https://delftswa.gitbooks.io/desosa2018/content/){:target='\_blank'}

## 精选极术专题，延伸 AIoT 知识边界

- [精选极术专题，延伸 AIoT 知识边界](https://aijishu.com/topics){:target='\_blank'}

## yck

- [前端进阶之道](https://yuchengkai.cn/){:target='\_blank'}

## 掘金

- [掘金翻译计划](https://github.com/xitu/gold-miner/search?q=web+browser){:target='\_blank'}

## 木易杨前端进阶

- [木易杨前端进阶](https://www.muyiy.cn/){:target='\_blank'}

## Lucas HC

- [Lucas HC](https://www.zhihu.com/people/lucas-hc/posts){:target='\_blank'}

## 前端面试总结 2020 年 8 月 16 家公司(附真实面试题)

- [前端面试总结 2020 年 8 月 16 家公司(附真实面试题)](https://segmentfault.com/a/1190000023731057){:target='\_blank'}
- [中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)](https://juejin.cn/post/6844903776512393224){:target='\_blank'}
- [awesome-coding-js](http://www.conardli.top/docs/)

- [10 Interview Questions Every JavaScript Developer Should Know](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95#.y0nc8kx34)
